HashMap中好的设计

//是返回大于输入参数且最近的2的整数次幂的数 比如10，则返回16。
static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }



AWK总结:
https://blog.csdn.net/jiaobuchong/article/details/83037467


java字节码指令:

https://www.cnblogs.com/longjee/p/8675771.html


JVM加载类
    1.加载
        查找字节流
        class文件 -> 内存:加载 -> 链接(验证) -> 初始化
        Java语言类型 : 基本类型 引用类型(类,接口,数组类,泛型参数)
        泛型参数在编译过程中会被擦除.
        数组类由jvm直接生成,类,接口有对应的字节流.

        启动类加载器(bootstrap class loader) 由c++实现,没有对应的java对象,在java中用null指代.
        除了启动类加载器,其他的类加载器都是java.lang.ClassLoader的子类。

        类加载:双亲委派模型.
            每当一个类加载器接收到加载请求时,他会先将请求转发给父类加载器,父类加载器没有找到所请求的类的情况下,该类加载器才会尝试加载.


        启动类加载器负责加载最为基础,最为重要的类,放在jre的lib目录下的jar包中的类。以及由-Xbootclasspath指定的类。

        扩展类加载器(extension class loader) 父类为启动类加载器,负责加载次要,通用的类。比如存放在jre 的lib/ext目录下的jar包中的类.
        以及java.ext.dirs指定的类.

        应用类加载器(application class loader) 父类为扩展类加载器。它负责加载应用程序路径下的类。

        java虚拟机中类的唯一性是由: 类加载器实例 + 类的全名一同确定.即便是同一串字节流,经由不同的类加载器加载,也会得到两个不同的类。
        在大型应用中,我们往往借助这一特性来运行类的不同版本。

    2.链接
        描述:将创建成的类合并至jvm中,使其能够执行的过程.

        验证 -> 准备 -> 解析

        验证:确保被加载的类能够满足jvm的约束条件。

        准备:为被加载的(类的静态字段分配内存)。除了分配内存外,部门jvm还会在此阶段构造其他跟类层次相关的数据结构,比如说用来实现虚方法的动态
            绑定的方法表。

        在class文件被加载至java虚拟机之前,这个类无法知道其他类及其方法,字段对应的具体地址,甚至不知道自己方法,字段的地址。因此,每当需要引用
        这些成员时,java编译器会生成一个符号引用。在运行阶段,这个符号引用一般都能无歧义的定位到具体目标。

        例如:对于一个方法调用,编译器会生成一个包含目标方法所在的类的名字,目标方法的名字,接收参数类型,以及返回值类型的符号引用,来指代要调用的
        方法.

        符号引用 = 类名 + 方法名 + 接收参数类型 + 返回参数类型

        解析:
            解析阶段的目的,将这些符号引用解析成实际引用.如果符号引用指向一个未被加载的类,或者未被加载类的字段或者方法,那么解析将触发这个类的加载

        如果某些字节码使用了符号引用,那么在执行这些字节码之前,需要完成对这些符号引用的解析。

    3.初始化
        在java代码中,如果要  初始化一个静态字段  我们可以在声明时直接赋值,也可以在静态代码块中赋值.
        如果
        (直接赋值的静态字段) 被(final) 修饰,并且( 他的类型是基本类型或字符串时) ,那么(该字段便会被java编译器标记成常量值),
        其初始化直接由java虚拟机完成。除此之外的直接赋值操作,以及静态代码块中的代码,则会被java编译器置于同一方法中,并把它命名为<clinit>

        类加载的最后一步是初始化,便是为标记为常量值的 字段赋值,以及执行 <clinit>方法的过程。
        jvm会通过加锁来确保类的<clinit>方法仅被执行一次。

        只有初始化完成之后,类才正式成为可执行的状态。

    4.类初始化触发的时机
        当虚拟机启动时,初始化用户指定的主类

        当遇到用以新建目标类实例的new指令时,初始化new指令的目标类

        当遇到调用静态方法的指令时,初始化该静态方法所在的类。

        当遇到访问静态字段的指令时,初始化该静态字段所在的类。

        子类的初始化会出发父类的初始化

        如果一个接口定义了default方法,那么直接实现或者间接实现该接口的类的初始化,会触发该接口的初始化

        使用反射api对某个类反射调用时,初始化这个类

        当初次调用methodHandler时,初始化该methodHandler指向的方法所在的类



