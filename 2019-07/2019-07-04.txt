复合索引:
    最窄的字段放在键的左边.
    如果很可能对一个列多次执行搜索,则该列应该是复合索引的第一列。

联合索引,最左前缀的原则,即最左优先。

如果我们建立了一个2列的联合索引(col1,col2),实际上已经建立了两个联合索引(col1)、(col1,col2）;
如果有一个3列索引(col1,col2,col3)，实际上已经建立了三个联合索引(col1)、(col1,col2)、(col1,col2,col3)。

b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)
这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；
但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，
必须要先根据name来搜索才能知道下一步去哪里查询。

比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，
所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，
即索引的最左匹配特性。（这种情况无法用到联合索引）


建了一个(a,b,c)的复合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，
都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销！

同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。
那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba
主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一

索引列越多，通过索引筛选出的数据越少
有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，
如果只有单值索引，那么通过该索引能筛选出1000W10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，
然后再排序，再分页；如果是复合索引，通过索引筛选出1000w 10% 10% 10%=1w，然后再排序、分页，哪个更高效，一眼便知


创建联合索引时列的选择原则
经常用的列优先（最左匹配原则）
离散度高的列优先（离散度高原则）
宽度小的列优先（最少空间原则）

列的离散性计算：count（distinct col）/ count(col)
离散性越高选择性越大



索引创建原则:
    最适合索引的列是出现在 WHERE 子句中的列，或连接子句中的列，而不是出现在 SELECT 关键字后的列。

