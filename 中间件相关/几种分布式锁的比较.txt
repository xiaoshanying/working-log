1.分布式锁应该具备哪些条件
    (1)在分布式系统环境下,一个方法在同一时间只能被一个机器的一个线程执行。
    (2)高可用的获取锁和释放锁(避免单点故障)
    (3)高性能的获取锁和释放锁
    (4)具备可重入特性
    (5)具备锁失效机制,防止死锁
    (6)具备非阻塞的特性,没有获取到锁将直接返回获取锁失败

2.基于数据库实现分布式锁
    核心思想:在数据库中建一张表,表中包含方法名(加唯一索引),类名,要想执行某个方法,就使用这个方法名向表中插入
            数据,成功插入则获取锁,执行完成后删除对应的行数据释放锁。
            当多个请求同时提交到数据库,数据库会保证只有一个可以操作成功,那么操作成功的那个线程获取到该方法的锁,
            可以执行方法体内容。
    成功插入获取锁,执行完成之后删除对应的行释放锁

3.基于数据库的分布式锁优缺点
    (1)数据库的可用性和性能将直接影响分布式锁的可用性以及性能。所以数据库要避免单点。
    (2)不可重入。因为同一个线程在释放锁之前,数据一直都在数据库,无法再次成功插入。解决:
       表中新增一列,记录机器信息 + 线程信息。当再次获取锁时,先查询当前机器 + 当前线程在表中
       是否存在数据,存在则直接获取锁。
    (3)没有锁失效机制
        可能插入数据之后,服务器宕机了,对应的数据没有被删除。当服务恢复后一直获取不到锁。
        解决方案:在表中增加一列,记录失效时间,开启定时任务去清除这些失效数据。(但是还是不能达到实时失效)
        对下一个线程获取锁还是有影响的。

    (4)不具备阻塞锁的特性。获取不到的话就直接返回了,不会去阻塞获取直到获取到。
       需要优化获取逻辑,循环多次获取。

4.基于redis实现
    用redLock可以实现高可用,高性能的获取到redis分布式锁。

5.基于zk
    利用同一个目录下只能有一个唯一的文件名这个特性来做。
    创建一个目录mylock
    线程A想要获取锁就在mylock下创建临时有序节点
    获取mylock目录下的所有子节点,获取比自己小的相邻节点,如果不存在,则说明当前线程顺序号最小,获得锁。
    线程B获取所有节点,如果自己不是最小节点,则监听比自己小一个的节点
    线程A处理完,删除自己的节点,线程B监听到变更事件,判断自己是不是最小的节点。如果是则获得锁。

6.zk作为分布式锁优点
    可以用Apache开源库Curator作为zk客户端 Curator InterProcessMutex是分布式锁实现。
    acquire获取锁
    release释放锁

7.zk分布式锁和redis分布式锁对比
    (1)获取锁
        redis:需要自己不断去尝试获取锁,比较耗性能
        zk:   获取不到锁,注册监听器即可,不需要不断主动尝试获取锁,性能开销小。

    (2)释放锁
        redis:客户端挂掉,需要等待key超时自动释放
        zk:   因为创建的是临时节点,只要客户端挂了,znode就没了,此时会自动释放锁。

