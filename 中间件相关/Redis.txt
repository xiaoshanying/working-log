1.redis是什么?
    内存数据库,缓存中间件

2.redis相比memcached优势在哪里?
    (1)支持持久化,rdb aof策略可以保证断电后数据会保存
    (2)数据类型多,memcached只支持字符串
    (3)redis速度快
    (4)redis value最大可以达到1G,memcached只有1M

3.redis支持的数据类型
    string hash list set zset mbit Pub/Sub 布隆过滤器

4.redis主要消耗什么物理资源
    内存

5.redis为什么单机并发量能达到那么高?
    请求过来 -> 建立scoket连接 -> 事件注册到io 多路复用上 ->如果某个事件就绪了 ->事件通过队列发送到事件分派器
    ->事件分派器根据事件选择对应的时间处理器(请求,回复,应答...)

    redis单线程是事件分派器单线程.

6.redis为什么快?
    纯内存操作
    io多路复用
    单线程没有线程切换开销

7.redis数据淘汰策略
    volatile-lru    从设置过期时间的数据集中挑选最近最少未使用的
    volatile-ttl    从设置过期时间的数据集中挑选将要过期的进行淘汰
    volatile-random 从设置过期时间的数据集中随机进行淘汰

    allkeys-lru     挑选最近最少未使用的
    allkeys-random  随机失效

    no-envction     不要淘汰

8.redis场景
    作为缓存
    分布式锁
    计数
    队列
    排名 zset

9.redis支持的客户端
    Jedis
        轻量,支持连接池,不支持读写分离,支持管道,lua,cluster,sentinel,事务
    Redisson(官方推荐使用)
        基于netty实现,nio性能高,支持异步,支持连接池
        不支持事务,用lua脚本解决
        支持读写分离,负载均衡,在主从和redis cluster下都可以使用

10.redis分区(类似于mysql分库分表)
    将数据分布到不同的redis实例,对于每个redis实例所存储的内容仅仅是所有内容的一个子集
    提升单机性能,提升并发处理能力,减少了单机存储导致所有服务不可用的风险

11.redis分区类型
    范围分区:
        将一个范围的key映射到同一个redis实例,但是需要维护key和实例之间的映射
    hash分区:
        id = hash(key)%N 算出redis节点编号
    分区实现方案:
        codis 代理,客户端将请求发送到redis代理服务器,代理服务器存储key与redis实例之间的关系
        redis cluster:请求会随机发往一个redis实例,这个redis实例负责将请求转发到正确的redis实例

12.分区之后会产生哪些问题
    多键操作不支持事务,因为不同的键都在不同的redis实例上
    添加,删除节点会导致部分缓存失效,因为计算节点的时候,hash出来的节点会发生变化

13.分布式redis一般前期做比较好,因为扩容起来是比较麻烦的,可以在一台机器上跑多个实例

14.redis内存占用情况查看
    redis-cli -h 127.0.0.1 -p 6379
    info memory 查看内存信息
    used_memory redis内存使用总量(缓存数据 + redis自身运行占用的内存)
    used_memory_rss 从操作系统上显示已经分配的内存总量
    mem_fragmentation_ration 内存碎片率
    used_memory_lua lua脚本引擎所使用的的内存的大小
    mem_allocator 在编译时指定的redis使用内存分配器

15.内存使用率需要监控
    如果一个redis实例的内存使用率超过最大的内存 used_memory > 可用最大内存,操作系统
    会进行内存与swap空间进行交换,把内存中旧的或不在使用的内容写入硬盘上(swap分区),以便腾出
    新的物理内存给新页或活动页使用
    所以我们要避免内存交换的发生:尽可能使用hash结构,设置key过期时间,回收key

16.redis服务处理命令的总数
    total_commands_processed

17.查询执行慢的命令
    slowlog get

18.redis持久化方式


19.redis分布式锁需要满足的条件
    互斥:任意时刻,智能有一个客户端获取到锁
    安全:不会形成死锁,当一个客户端在持有锁的期间崩溃而没有主动释放锁的情况下,其持有的
         锁也能被正确释放,并保证后序其他客户端能正常加锁
    可用性:只要大多数redis节点正常,客户端都应该可以获取锁和释放锁。
    对称性:对于任意一个锁,加锁和解锁必须是同一个客户端.

20.RedLock分析
   (1)直接setnx命令设置锁,加超时时间,释放锁时直接del这样存在的问题?
        如果系统单点故障,redis节点down机,则所有客户端都拿取不到锁
   (2)基于问题1,如果加一个slave节点,master节点宕机,slave节点顶上去提供服务,这样存在的问题?
        不能保证互斥性。假如A客户端获取到锁,此时master挂掉了,并且,master数据还没同步到slave
        这时slave升为master,B从slave获取到了锁。（因为此时slave并没有A的信息）
        导致两个客户端获取到了同一把锁。
   (3)单实例实现(单点情况不会有问题)
        SET resource_name my_random_value NX PX 30000
        这个命令的作用是在只有这个key不存在的时候才会设置这个key的值（NX选项的作用），
        超时时间设为30000毫秒（PX选项的作用） 这个key的值设为“my_random_value”。这个值必须在所有获取锁请求的客户端里保持唯一
        基本上这个随机值就是用来保证能安全地释放锁，
        我们可以用下面这个Lua脚本来告诉Redis：删除这个key当且仅当这个key存在而且值是我期望的那个值。
        if redis.call("get",KEYS[1]) == ARGV[1] then
                return redis.call("del",KEYS[1])
            else
                return 0
            end
        Object result = jedis.eval(luaScript, Collections.singletonList(realKey),Collections.singletonList(value));
                    if ("1".equals(result)) {
                        return true;
                    }

        为什么要去判断key对应的值是否是当前客户端设置的随机值?
            避免误删其他客户端得到的锁

        例子:
            一个客户端拿到了锁，被某个操作阻塞了很长时间，过了超时时间后自动释放了这个锁，
            然后这个客户端之后又尝试删除这个其实已经被其他客户端拿到的锁。所以单纯的用DEL指令有可能造成一个客户端删除了其他客户端的锁，
            用上面这个脚本可以保证每个客户单端都用一个随机字符串’签名’了，这样每个锁就只能被获得锁的客户端删除了。

            假如A获取到锁,执行一段耗时逻辑,此时锁超过超时时间,释放锁,
                    B此时拿到锁
            A执行完耗时逻辑,删除锁(这里就会有问题,因为此时的锁根本不是自己申请的那一把,自己的已经超时了,如果单纯用del删除,而不去判断
            到底是不是自己的锁的话,那么就会导致锁被误删除)

        随机字符串如何生成?
            毫秒unix时间 + 客户端id 等

        key超时时间:
            锁有效时间,这个是锁的自动释放时间，也是一个客户端在其他客户端能抢占锁之前可以执行任务的时间，这个时间从获取锁的时间点开始计算

   (4)RedLock算法(分布式下的解决方案,防止单redis节点故障导致整体不能加锁)
        假设有N个master节点,节点完全独立
        一个客户端需要做如下操作来获取锁:
            i:获取当前时间(毫秒)
           ii:轮流用相同的key和随机值在N个节点上请求锁。客户端在每个master上请求锁时，《会有一个和总的锁释放时间相比小的多的超时时间》。
              比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，
              这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间.

          iii:客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（N/2+1），而且总共消耗的时间不超过锁释放时间，
              这个锁就认为是获取成功了。

         iiii:如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间
              设置的有效时间 - (加锁花费的时间) - 同步时钟花费时间
        iiiii:如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)
              还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。

   (5)api
        RLock rlock = redisson.getLock("");
        rlock.lock()
        ...
        rlock.unlock()

        //尝试加锁 最多等待100秒,上锁后10秒解锁
        lock.trylock(100,10,TimeUnit.SECONDS);

        //公平锁 保证当多个客户端线程同时请求加锁,优先分配给先发出请求的线程
        redisson.getFairLock("");

        //联锁,当同时加上n把锁,才算加锁成功
        RedissonMultiLock

        //红锁
        RedissonRedLock

        //读写锁
        RReadWriteLock

        //信号量
        RSemaphore

        //闭锁
        RCountDownLatch

21.scan获取指定key的列表
    为什么不用Keys。因为当量级很大时,执行keys会阻塞执行,redis是单线程处理事件的,所以会阻塞
    其他的业务,用scan可以无阻塞的获取指定Key的列表

22.redis队列
    lpush生产消息,lpop消费消息,可以用blpop阻塞的获取消息

23.大量key同一时间过期需要注意
    单线程redis去过期指定数量的key,由于执行时间较长,会阻塞其他请求。一般过期时间加一个随机值,分散过期时间。

24.如果想要机器断电,只有少量数据丢失的话
    需要配置sync刷盘时间,一般1s1次,这样最多丢失1s的数据

25.快照全量备份原理
    (1).redis fork出来一个子进程
    (2).父进程继续处理请求,子进程将内存内容写入临时文件。
        os的copy on write父子进程会共享相同的物理内存页。当父进程处理请求时,os会为父进程要修改的页面
        创建副本,在副本上修改。修改完之后,替换掉之前的。因为写的时候是在副本写,所以子进程的地址空间
        内的数据是fork时刻整个数据库的快照。
    (3).子进程将快照写入临时文件完毕后,用临时文件替换原来的快照文件，子进程退出。

26.AOF配置
    appendonly yes //启用aof
    appendfsync always //收到写命令就立即写入磁盘,最慢,但是可以保证完全的持久化
    appendfsync everysec //每秒中写入磁盘一次,在性能和持久化方面做了折中
    appendfsync no //性能最好,持久化无保证


27.如何选择合适的持久化方式
    一般用快照 + aof
    开机时重放rdb构建内存数据,在结合aof重放近期操作的命令

28.管道好处
    多次命令,压缩成一次。减少网络请求次数,节省io。




