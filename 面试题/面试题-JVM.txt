1.JVM内存结构
    堆:新生代（eden s1 s2） 老年代
    栈:本地方法栈,虚拟机栈
    元数据区:存放类信息,常量,静态变量,jit后的代码
    程序计数器(记录当前线程执行到字节码的哪一行)

2.新生代
    内存占比 eden s1 s2 8 : 1 : 1
    采用复制算法进行垃圾回收
    复制算法基本思想:将内存分为两块,每次只用其中一块,当一块内存不够分配了,就将
    还活着的对象复制到另一块上面,并且将当前这一块清空。
    复制算法不会产生内存碎片,但是会浪费一定比例的存储空间

3.老年代
    垃圾回收算法:标记-清除
    会产生内存碎片,回收算法CMS

4.年轻代GC过程
    eden s0(from) s1(to) old
    开始时,对象创建放在eden中
    当来一个对象,发现eden区没有足够的空间可以分配,此时触发minor gc
    (1)eden区存活对象复制到to区,
    (2)from区如果年龄未达到指定年龄,则from区的对象复制到to区
    (3)from区如果年龄达到晋升到老年代的年龄,则对象复制到old区
    (4)此时 eden区和from区都已经空出来
    再次进行minor gc时,原先的from 变成to,原先的to变成from
    如果to区被填满,所有的对象都会移动到老年代

5.年轻代JVM参数
    -XX:NewSize 和 -XX:MaxNewSize设置年轻代的大小,一般设置为整个堆的1/3 或者 1/4
    -XX:SurvivorRatio eden区和s区的比例
    -XX:PrintTenuringDistribution 显示每次minor gc时,s区各个年龄段对象的分布
    -XX:InitialTenuringThreshold和-XX:MaxTenuringThreshold用于设置晋升到老年代的对象
        年龄的最大值和最小值,每个存活的对象在一次minor gc后,年龄加1

6.GC触发条件
    YGC:eden空间不足
    FGC:old空间不足,perm空间不足,显示调用system.gc()

7.判断对象不可用方法?
    (1)引用计数法
        原理:对象被引用,计数器加1,失效,计数器减1。当计数器为0的时候,JVM认为对象不再被引用,可以回收
        优点:实现简单,效率高
        缺点:不能解决循环引用问题,A引用B，B引用A，A，B都不再被其他对象引用,此时计数器为1
    (2)可达性分析
        原理:GC ROOTS作为起点,从这些节点向下搜索,当一个对象没有到GC ROOTS的引用时,说明不可用
        GC ROOTS:虚拟机栈(栈桢中的本地变量表)中引用的对象
                 方法区中静态属性引用的对象
                 方法区中常量引用的对象
                 native方法引用的对象
8.垃圾回收算法
    (1)标记清除:
        原理:标记阶段,标记要回收的对象。清除阶段,将不可用对象清除
        优缺点:效率不高,清除后大量空间不连续,这样当大对象进来时,一样分配不了
    (2)复制算法:
        原理:内存等分两块,每次只使用一块,当垃圾回收的时候,把存活的对象复制到另一块,然后把当前这块整个清理掉。
        优缺点:实现简单,运行效率高。内存利用率不高,每次都会有一块空置eden:s(8:2)
    (3)标记整理:
        原理:把存活对象移动到内存的一端,回收边界之外的内存

9.垃圾收集器
    新生代:串行收集器,ParNew,并行收集器
    老年代:CMS,串行老年,并行老年
    G1:跨老年和新生

10.Serial收集器
    新生代收集器,单线程,复制算法,进行垃圾收集时,会暂停其他工作线程(单CPU效果好)

11.ParNew
    Serial的多线程版本,可以使用-XX:UseParNewGC来强制开启。
    可以通过-XX:ParallelGCThreads 来调整或者限制垃圾收集的线程数量。

12.Parallel Scavenge
    并行多线程收集 复制算法
    目标:吞吐量可控 吞吐量 = 程序运行时间 / (运行时间 + 收集时间)
    例如:运行100分钟,收集1分钟 = 99 / (99 + 1) = 99%
    参数:-XX:MaxGCPauseMillis -XX:GCTimeRatio
    MaxGCPauseMillis允许值是一个大于0的毫秒数,收集器将尽可能的保证内存回收花费的时间不超过设定值
    但是这个值不是设置越小越好
    GCTimeRatio参数的值应当是一个大于0且小于100的整数,垃圾收集时间占总时间的比率,相当于吞吐量的倒数.
    -XX:UseAdaptiveSizePolicy gc自适应调节

13.Serial Old
    串行的老年代版本,单线程收集,使用标记-整理算法。
    server模式下作为CMS后备,在并发收集时可能出现Concurrent Mode Failure

14.Parallel Old
    Parallel Scavenge的老年代版本,注重吞吐量以及CPU资源敏感场合,可以优先考虑

15.CMS收集器
    目标:最短回收停顿时间
    应用:互联网,B/S系统服务端,可以提高响应速度
    算法:标记-清除
    步骤:
        初始标记:单线程标记,只是标记一下gc roots能直接关联到的对象,速度很快
        并发标记:gc root tracing
        重新标记:为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录
        并发清除
    问题:
        CMS无法处理浮动垃圾,可能出现"Concurrent Mode Failure"失败而导致一次Full gc的产生
        CMS并发清理阶段用户线程还在运行,伴随着程序的运行会不断有新垃圾的产生,这一部分垃圾出现在
        标记之后,CMS无法在当次收集中处理掉他们,只好留到下一次GC时在清理掉,这部分垃圾称为浮动垃圾。

        垃圾收集阶段,用户程序还是要运行的,所以要预留足够的内存空间给用户线程使用。

