1.错误的更新姿势
  A,B两个请求将ID为1的用户的年龄进行更新,A将age更新为19,B将age更新为21。
  错误的更新:先更新数据库,再去更新缓存
  原因:高并发下,A更新数据库age -> 19,
              此时B过来,将age -> 21,然后B将缓存中的age ->21。
              A将缓存数据更新为age ->19。
       这种情况下,缓存的数据就有可能变为脏数据。
  为什么?
  因为变更数据库和变更缓存是两个独立的操作，而我们并没有对操作做任何的并发控制。
  那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据的不一致。

2.如何解决1中的问题--旁路缓存
  (1)更新数据时不更新缓存,而是删除缓存中的数据,在读取数据时,发现缓存中没有数据,再从数据库中读取数据,更新到缓存中。
     这个策略叫做Cache Aside(旁路缓存),这个策略以数据库中的数据为准,缓存数据按需加载。
  (2)读策略
     从缓存中读取数据 -> 缓存命中,直接返回数据 -> 缓存不命中,从数据库查询数据 ->查询到数据,将数据写入缓存,并且返回给用户。
  (3)写策略
     更新数据库中的记录,删除缓存记录。
  (4)疑问,为什么不能先删缓存,在更新数据库呢?
     当前用户age 20,
     请求A过来,删除缓存,
     请求B过来查缓存,发现缓存没数据,去查数据库,此时A还没来得及更新,当前age 20,回写到缓存,
     A修改age -> 21,此时缓存的数据是脏数据
3.Cache Aside 策略是我们日常开发中最经常使用的缓存策略，不过我们在使用时也要学会依情况而变
  比如说当新注册一个用户，按照这个更新策略，你要写数据库，然后清理缓存（当然缓存中没有数据给你清理）。
  可当我注册用户后立即读取用户信息，并且数据库主从分离时，会出现因为主从延迟所以读不到用户信息的情况。
  而解决这个问题的办法恰恰是在插入新数据到数据库之后写入缓存。

4.读穿,写穿策略(使用本地缓存时可以考虑这种策略)
  (1)核心原则:用户只和缓存打交道。缓存和数据库通信,写入或者读取数据。
  (2)写穿策略:先查询要写入的数据在缓存中是否存在
             存在 -> 更新缓存数据,缓存组件同步更新到数据库
            不存在 -> 这种情况称为Write Miss(写失效)
                     写失效应对方法:
                                按写分配,写入缓存,缓存写入数据库。
                                不按写分配,不写缓存,直接写入数据库。（一般选择,少一次写缓存,性能好一点）

  (3)读穿策略:先查缓存中的数据是否存在
             存在 -> 直接返回
           不存在 -> 由缓存组件负责从数据库中同步加载数据

5.写回策略
  (1)核心:写入数据时只写入缓存,并且把缓存块标记为"脏",脏块只有被再次使用时才会将其中的数据写入到后端存储。
  (2)读策略:缓存命中,直接返回
           不命中 -> 寻找一个可用缓存块 -> 缓存块是否为脏?
                                        脏 -> 缓存块儿中之前的数据写入到后端存储中，并且从后端存储加载数据到缓存块儿
                                       不脏 -> 则由缓存组件将后端存储中的数据加载到缓存中，最后我们将缓存设置为不是脏的，返回数据
  (3)场景?
     不能被应用到我们常用的数据库和缓存的场景中
     我们在向磁盘中写数据时采用的就是这种策略
     操作系统层面的 Page Cache，还是日志的异步刷盘，亦或是消息队列中消息的异步写入磁盘，大多采用了这种策略
     你在向低速设备写入数据的时候，可以在内存里先暂存一段时间的数据，甚至做一些统计汇总，然后定时地刷新到低速设备上。
     比如说，你在统计你的接口响应时间的时候，需要将每次请求的响应时间打印到日志中，然后监控系统收集日志后再做统计。
     但是如果每次请求都打印日志无疑会增加磁盘 I/O，那么不如把一段时间的响应时间暂存起来，经过简单的统计平均耗时，每
     个耗时区间的请求数量等等，然后定时地，批量地打印到日志中。

