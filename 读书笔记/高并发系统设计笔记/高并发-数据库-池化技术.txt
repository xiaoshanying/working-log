1.抓取mysql连接信息
  tcpdump -i bond0 -nn -tttt port 3306(具体端口)

2.mysql连接两个部分
  TCP三次握手
  mysql服务端校验客户端密码

3.耗时
  mysql建立连接耗时4ms,sql平均执行时间1ms,也就是说mysql连接建立过程远比执行sql耗时久。

4.如何优化?
    数据库连接池

5.连接池?
    连接池有两个重要的参数:最小连接数和最大连接数,它们控制着从连接池中获取连接的流程：
       (1)如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；
       (2)如果连接池中有空闲连接则复用空闲连接；
       (3)如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求；
       (4)如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；
       (5)如果等待超过了这个设定时间则向用户抛出错误。

6.经验之谈
   一般在线上我建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可。

7.池子中连接维护问题?
   问题来源:连接池中缓存了一部分连接,此时配置文件mysql的连接地址发生了变化。那么池子中的连接被使用时就会发生错误。
   MySQL 有个参数是“wait_timeout”，控制着当数据库连接闲置多长时间后，数据库会主动的关闭这条连接。
   这个机制对于数据库使用方是无感知的，所以当我们使用这个被关闭的连接时就会发生错误。

   解决上述问题,怎么保证连接的可用。
   (1)启动一个线程来定期检测连接池中的线程是否可用。比如使用连接发送“select 1”的命令给数据库看是否会抛出异常，
      如果抛出异常则将这个连接从连接池中移除，并且尝试关闭。目前 C3P0 连接池可以采用这种方式来检测连接是否可用。
   (2)在获取到连接之后，先校验连接是否可用，如果可用才会执行 SQL 语句。比如 DBCP 连接池的 testOnBorrow 配置项，
      就是控制是否开启这个验证。这种方式在获取连接时会引入多余的开销，在线上系统中还是尽量不要开启，在测试服务上可以使用。

8.由连接池引申出来的线程池
   JDK 1.5 中引入的 ThreadPoolExecutor 就是一种线程池的实现，它有两个重要的参数：coreThreadCount 和 maxThreadCount，
   这两个参数控制着线程池的执行过程。

   如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；
   如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；
   当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；
   当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了。

   JDK 实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程，它比较适用于执行 CPU 密集型的任务，
   也就是需要执行大量 CPU 运算的任务。这是为什么呢？因为执行 CPU 密集型的任务时 CPU 比较繁忙，因此只需要创建和 CPU 核数相当的线程就好了，
   多了反而会造成线程上下文切换，降低任务执行效率。所以当当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。

   但是，我们平时开发的 Web 系统通常都有大量的 IO 操作，比方说查询数据库、查询缓存等等。任务在执行 IO 操作的时候 CPU 就空闲了下来，
   这时如果增加执行任务的线程数而不是把任务暂存在队列中，就可以在单位时间内执行更多的任务，大大提高了任务执行的吞吐量。所以你看
   Tomcat 使用的线程池就不是 JDK 原生的线程池，而是做了一些改造，当线程数超过 coreThreadCount 之后会优先创建线程，直到线程数到达
   maxThreadCount，这样就比较适合于 Web 系统大量 IO 操作的场景了，你在实际运用过程中也可以参考借鉴。

   线程池中使用的队列的堆积量也是我们需要监控的重要指标，对于实时性要求比较高的任务来说，这个指标尤为关键。

   实际项目中就曾经遇到过任务被丢给线程池之后，长时间都没有被执行的诡异问题。后来经过排查发现，
   是因为线程池的 coreThreadCount 和 maxThreadCount 设置的比较小，导致任务在线程池里面大量的堆积，在调大了这两个参数之后问题就解决了。

   如果你使用线程池请一定记住不要使用无界队列（即没有设置固定大小的队列）。也许你会觉得使用了无界队列后，任务就永远不会被丢弃，
   只要任务对实时性要求不高，反正早晚有消费完的一天。但是，大量的任务堆积会占用大量的内存空间，一旦内存空间被占满就会频繁地触发 Full GC，
   造成服务不可用，我之前排查过的一次 GC 引起的宕机，起因就是系统中的一个线程池使用了无界队列。
